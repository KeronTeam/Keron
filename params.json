{"name":"Keron","tagline":"Kerbal Online - Multiplayer KSP Mod.","body":"Keron\r\n=====\r\n\r\n**Ker**bal **On**line.\r\n\r\nEnabling you to play with friends (and foes?).\r\n\r\nHeavy inspiration from and credits to [KMP](https://github.com/TehGimp/KerbalMultiPlayer).\r\n\r\nIf you are looking for a (somewhat) working product, please head over to [DarkMultiPlayer](https://github.com/godarklight/DarkMultiPlayer).\r\n\r\nDependencies\r\n------------\r\n\r\n- [ENet](http://enet.bespin.org/): Network library.\r\n- [ENetCS](https://github.com/KeronTeam/enetcs): ENet for C# bindings (client-side).\r\n- [FlatBuffers](https://github.com/google/flatbuffers): Serialization library.\r\n- [Vedis](https://github.com/symisc/vedis): redis-like embedded datastore (server-side).\r\n\r\nBuilding\r\n--------\r\n\r\nThe project dependencies are rather small and self-sufficient.\r\nTherefore, we use [submodules](http://www.git-scm.com/book/en/v2/Git-Tools-Submodules) to guarantee\r\nthat we share the same version across all builds.\r\n\r\nGet the submodules:\r\n```sh\r\ngit submodule init\r\ngit submodule update\r\n```\r\n\r\n\r\nGet a copy of [Premake 5](http://premake.bitbucket.org/download.html#v5), and make it available in your PATH.\r\nThen run premake with your flavor of arguments:\r\n```sh\r\n# Linux build\r\npremake5 --cc=clang gmake\r\n\r\n# Windows build\r\npremake5 vs2013\r\n```\r\n\r\nYour solution/Makefile files will be in the `build/` directory.\r\n\r\nDesign\r\n------\r\n\r\n**THIS SECTION IS OUT OF DATE**. See the issues for details.\r\n\r\nThe server runs in non-authoritative fashion:\r\nclients send updates and they are broadcasted to everybody through the server.\r\n\r\n### KSC\r\n\r\n**THIS SECTION IS OUT OF DATE**. See the issues for details.\r\n\r\nThe KSC launchpad and runway are viewed as shared resources: one player is allowed at a given time.\r\n\r\nTwo cylindrical corridors are defined for each shared resource. As long as there is something in the corridor\r\n(an active player, a debris, a plane, a bird, superman...), a player cannot claim the resource.\r\n\r\nFor the launchpad, it would be a corridor 100m wide and 10km tall (note: subject to change).\r\nFor the runway, it would be 100m tall and 500m wide before and after the track.\r\n\r\nExample:\r\n\r\n* Alice requests a launch. The corridor is clear, he acquires it and proceed to his launch.\r\n* Bob sees that Alice has reached the 10k limit. He requests a launch, but there are unlanded debris: he must wait.\r\n* After a time, Bob requests the corridor. All debris are landed, the 10k corridor is clear,\r\n  but there are debris on the launchpad (such as [TT18-A LSE](http://wiki.kerbalspaceprogram.com/wiki/TT18-A_Launch_Stability_Enhancer)s).\r\n  He can clear it using the standard _Clear Launchpad_ button.\r\n\r\nIf a player disconnects while in a corridor, its vessel shall be destroyed immediately.\r\n\r\n### Warp\r\n\r\n**THIS SECTION IS OUT OF DATE**. See the issues for details.\r\n\r\nWarping handling is probably _the_ most challenging issue of networked KSP.\r\nDisabling it all together is not a valid option (who would spend _months_ to get to Eve,\r\nor simply _hours_ to get to the Mun?).\r\n\r\nSame goes with a shared warp-time\r\n\r\nImagine:\r\n> Got to go to Eve. warping x1000. Sorry folks who were doing high-precision docking manoeuvers!\r\n\r\nOr even:\r\n> Got to re-entry. I take the lock on the time. Sorry folks who'd like to go to Eve before retirement!\r\n\r\nThose are simply unacceptable from a gameplay perspective.\r\n\r\nThe answer to this is simple: subspaces. Each player plays in his own timeline, and may catch up with the server.\r\nThe server time is simply the highest available.\r\n\r\nThis system implies a very simple, very important rule: _one cannot interact with a vessel's past or future._ **Ever.**\r\n\r\nReason is that you weren't there at that time.\r\nSo you shouldn't interfere with the vessel if you have not caught up with it.\r\nIt's completely unlogical from a realistic perspective but we believe it to be to the gameplay's profits.\r\nAnd we would not have to deal with alternatives futures, which would be a mess.\r\n\r\nMoreover a player may never go back in his own timeline (just trust the Time Lords on this).\r\n\r\nThis together means:\r\n\r\n* **Late** players would see a _replay_ of future ships, as well as their trajectories.\r\n* **Current** players would see past ship with a _predicted trajectories_, which may change at any time.\r\n\r\n> But what happens if a past ship is on collision course with a future ship?\r\n\r\nWell, that's tricky. Let me put that simply: **they will collide at the point and time they should collide.**.\r\n\r\nMultiplayer KSP is no fairy tale.\r\n\r\nTechnicalities\r\n--------------\r\n\r\n**THIS SECTION IS OUT OF DATE**. See the issues for details.\r\n\r\nThe client is a standard KSP Plugin. Though it originally intended to leverage Unity Networking functionalities, this turned out a dead end (basically, client would have to maintain deep copies of watched objects for the network serializer to kick in).\r\n\r\nInstead, we use [Lidgren.Net](http://code.google.com/p/lidgren-network-gen3/).\r\n\r\nBoth the client and the server are written in C# and relies on:\r\n\r\n* KSP (duh).\r\n* [Lidgren.Net](http://code.google.com/p/lidgren-network-gen3/)\r\n* [ZLibNet](https://zlibnet.codeplex.com/) and [ZLib](http://zlib.net/) (used for compressing _large_ datasets)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}